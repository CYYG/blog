= 13/01/2019
Julien Kirch
v1.0, 2019-01-13
:article_lang: en

===== link:https://blog.filippo.io/mkcert-valid-https-certificates-for-localhost/[mkcert: valid HTTPS certificates for localhost]

[quote]
____
mkcert is a simple by design tool that hides all the arcane knowledge required to generate valid TLS certificates. It works for any hostname or IP, including localhost, because it only works for you.

Here's the twist: it doesn't generate self-signed certificates, but certificates signed by your own private CA, which your machine is automatically configured to trust when you run mkcert -install. So when your browser loads a certificate generated by your instance of mkcert, it will show up with a green lock!
____


===== link:https://infrequently.org/2018/09/the-developer-experience-bait-and-switch/[The “Developer Experience” Bait-and-Switch]

[quote]
____
The “developer experience” bait-and-switch works by appealing to the listener’s parochial interests as developers or managers, claiming supremacy in one category in order to remove others from the conversation. The swap is executed by _implying_ that by making things better for developers, users will eventually benefit equivalently. The unstated agreement is that developers share all of the same goals with the same intensity as end users and even managers. _**This is not true**_.

Shifting the conversation away from _actual_ user experiences to team-level advantages enables a culture in which the folks who receive focus and attention are developers, rather than end-users or the business. It naturally follows that teams can then substitute _tools_ for _goals_.
____

===== link:https://infrequently.org/2018/09/the-developer-experience-bait-and-switch/[The State Of Software Security In 2019]

[quote]
____
Static checkers — compilers — and dynamic checkers (e.g. Address Sanitizer and the rest of the LLVM sanitizers) have advanced very far in the past 20 years. What was once bleeding-edge research now comes for free with off-the-shelf compilers. This is fantastic! 
____

[quote]
____
And unfortunately, the problems that I find the most vexing — the abuse category generally — are not in my area of greatest expertise. My heart is really in the language problem: meaningful interfaces, ergonomic and safe libraries, memory safety, and type safety. But it’s the abuse that makes my heart sick.
____

===== link:https://www.hillelwayne.com/post/stamping-on-eventstream/[STAMPing on event-stream]

[quote]
____
“Who did this” is the wrong question. “How did this happen” is the wrong question. A better question is “why was this possible in the first place?”

An accident isn’t something that just happens. Accidents aren’t isolated failures. Accidents aren’t human error. Accidents aren’t simple. Accidents are _complicated_. Accidents are symptomatic of much deeper, more insidious problems across the entire system.

This is the core insight of Leveson. Instead of thinking about accidents as things with root causes, we think of them as failures of the entire system. The system had a safety *constraint*, something that was supposed to be prevented. Its *controls*, or means of maintaining the constraints, were in some way inadequate.

The purpose of a postmortem should be to prevent _future accidents_. We don’t just stop the analysis once we find a scapegoat. Sure, we can say “Tarr transfered it over”, but why did that lead to an accident? Why did he want to abandon it? Why was he able to transfer it over? Why did nobody notice he transferred it? Why was a single dependency able to affect Copay? Why was a random internet dev so critical in the first place?

Leveson aggregated all of her safety approaches under the umbrella term STAMP. We’re going to analyse the attack via STAMP and see if we can get better findings than “Tarr don’t software good.”
____

[quote]
____
This is what most people focused on, despite being the most superficial bit. Problem: Tarr gave access rights to an internet rando. Solution: tell people to vet internet randos. This would presumably be enforced by demanding maintainers have better discipline.

This places additional responsibilities on the open source maintainer. One law we see time and time again is “you cannot fix things with discipline.” First of all, they simply don’t work: see all the data breaches at professional, “responsible” companies. Also, discipline approaches do not scale. This problem happened because a single contributor for a single package made an error. At the time of the attack, Copay had thousands of package dependencies. That means that thousands of maintainers cannot make any mistakes or else the system is in trouble. And even if they all have perfect discipline, this still doesn’t prevent dependency attacks. A malicious actor could seed a package and use it later, or steal someone else’s account.
____

==== link:https://dzone.com/articles/abstraction-tiers-of-notations[Abstraction Tiers of Notations (Part 1)]

[quote]
____
Abstractions from different tiers have different learning and usage cost. The higher tier abstractions are more taxing to use and more difficult to learn than those of lower tiers. However, these higher-tier abstractions allow decomposing more complex task in manageable pieces. The lower tier abstractions have lower learning and usage cost, but they support lesser complexity. Depending on the situation, these factors could have different weight.

Thus, targeting the highest tier possible is not a sure-win strategy. 

One of the good solutions to this trade-off is designing languages that support abstractions from different tiers. For example, Java forces to use class abstraction (tier 4) even for simplest programs. On the other hand, Groovy allows writing programs using a sequence of actions as the script (the tier 2-3 on top level). So, it is possible to choose a high-level abstraction tier suitable of the specific task and not to pay the cost of higher-tier abstractions.
____
